/*
Deployment script for RetailPulse_DW

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "RetailPulse_DW"
:setvar DefaultFilePrefix "RetailPulse_DW"
:setvar DefaultDataPath "C:\Users\papai\AppData\Local\Microsoft\VisualStudio\SSDT\RetailPulse_DW_CI"
:setvar DefaultLogPath "C:\Users\papai\AppData\Local\Microsoft\VisualStudio\SSDT\RetailPulse_DW_CI"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                CURSOR_DEFAULT LOCAL 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET PAGE_VERIFY NONE,
                DISABLE_BROKER 
            WITH ROLLBACK IMMEDIATE;
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE (QUERY_CAPTURE_MODE = ALL, CLEANUP_POLICY = (STALE_QUERY_THRESHOLD_DAYS = 367), MAX_STORAGE_SIZE_MB = 100) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
PRINT N'Creating Schema [config]...';


GO
CREATE SCHEMA [config]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [prod]...';


GO
CREATE SCHEMA [prod]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [raw]...';


GO
CREATE SCHEMA [raw]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [stage]...';


GO
CREATE SCHEMA [stage]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [utils]...';


GO
CREATE SCHEMA [utils]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Table [config].[CountryInfo]...';


GO
CREATE TABLE [config].[CountryInfo] (
    [Id]             INT            IDENTITY (1, 1) NOT NULL,
    [CountryName]    NVARCHAR (255) NULL,
    [Currency]       NVARCHAR (10)  NULL,
    [CurrencySymbol] NVARCHAR (100) NULL,
    [InsertedAt]     DATETIME       NULL,
    PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Table [config].[HashColumns]...';


GO
CREATE TABLE [config].[HashColumns] (
    [Id]         INT            IDENTITY (1, 1) NOT NULL,
    [DatasetId]  INT            NOT NULL,
    [ColumnName] NVARCHAR (255) NOT NULL,
    [HashString] NVARCHAR (255) NOT NULL,
    [HashOrder]  INT            NOT NULL,
    PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Table [config].[Datasets]...';


GO
CREATE TABLE [config].[Datasets] (
    [Id]                INT            IDENTITY (1, 1) NOT NULL,
    [Dataset]           NVARCHAR (100) NOT NULL,
    [DatasetSource]     NVARCHAR (255) NOT NULL,
    [SourceRefreshType] NVARCHAR (50)  NOT NULL,
    [LoadTable]         NVARCHAR (255) NULL,
    [ProcessingTable]   NVARCHAR (255) NULL,
    [FinalTable]        NVARCHAR (255) NULL,
    [CreatedAt]         DATETIME       NULL,
    PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Table [prod].[TransactionsFact]...';


GO
CREATE TABLE [prod].[TransactionsFact] (
    [TransactionId]            INT             IDENTITY (1, 1) NOT NULL,
    [TransactionBK]            NVARCHAR (50)   NOT NULL,
    [UserId]                   INT             NOT NULL,
    [ProductId]                INT             NOT NULL,
    [ExchangeRateId]           INT             NOT NULL,
    [DateKey]                  INT             NOT NULL,
    [Currency]                 NVARCHAR (3)    NOT NULL,
    [ProductLocalPrice]        DECIMAL (18, 2) NOT NULL,
    [ProductStandardizedPrice] DECIMAL (18, 2) NOT NULL,
    [CartLocalPrice]           DECIMAL (18, 2) NOT NULL,
    [CartStandardizedPrice]    DECIMAL (18, 2) NOT NULL,
    [InsertedAt]               DATETIME        NULL,
    PRIMARY KEY CLUSTERED ([TransactionId] ASC)
);


GO
PRINT N'Creating Table [prod].[UsersDim]...';


GO
CREATE TABLE [prod].[UsersDim] (
    [UserId]          INT              IDENTITY (1, 1) NOT NULL,
    [Source]          NVARCHAR (255)   NULL,
    [Gender]          CHAR (1)         NOT NULL,
    [FullName]        NVARCHAR (255)   NOT NULL,
    [FirstName]       NVARCHAR (100)   NOT NULL,
    [LastName]        NVARCHAR (100)   NOT NULL,
    [Email]           NVARCHAR (320)   NOT NULL,
    [SubTerritoryId]  INT              NOT NULL,
    [BUSINESSKEYHASH] VARBINARY (6000) NULL,
    [HASHDATA]        VARCHAR (MAX)    NULL,
    [EffectiveDate]   DATETIME         NOT NULL,
    [ExpirationDate]  DATETIME         NOT NULL,
    [IsCurrent]       BIT              NOT NULL,
    PRIMARY KEY CLUSTERED ([UserId] ASC)
);


GO
PRINT N'Creating Table [prod].[SubTerritoriesDim]...';


GO
CREATE TABLE [prod].[SubTerritoriesDim] (
    [SubTerritoryId]  INT              IDENTITY (1, 1) NOT NULL,
    [TerritoryId]     INT              NOT NULL,
    [City]            NVARCHAR (100)   NOT NULL,
    [StreetName]      NVARCHAR (255)   NULL,
    [Latitude]        DECIMAL (9, 6)   NULL,
    [Longitude]       DECIMAL (9, 6)   NULL,
    [CreatedAt]       DATETIME         NULL,
    [BUSINESSKEYHASH] VARBINARY (6000) NULL,
    [HASHDATA]        VARCHAR (MAX)    NULL,
    PRIMARY KEY CLUSTERED ([SubTerritoryId] ASC)
);


GO
PRINT N'Creating Table [prod].[TerritoriesDim]...';


GO
CREATE TABLE [prod].[TerritoriesDim] (
    [TerritoryId]     INT              IDENTITY (1, 1) NOT NULL,
    [Country]         NVARCHAR (100)   NOT NULL,
    [State]           NVARCHAR (100)   NOT NULL,
    [CreatedAt]       DATETIME         NULL,
    [BUSINESSKEYHASH] VARBINARY (6000) NULL,
    [HASHDATA]        VARCHAR (MAX)    NULL,
    PRIMARY KEY CLUSTERED ([TerritoryId] ASC)
);


GO
PRINT N'Creating Table [prod].[ExchangeRatesDim]...';


GO
CREATE TABLE [prod].[ExchangeRatesDim] (
    [ExchangeRateId] INT             IDENTITY (1, 1) NOT NULL,
    [Country]        NVARCHAR (100)  NOT NULL,
    [Currency]       NVARCHAR (3)    NOT NULL,
    [RateToEUR]      DECIMAL (18, 6) NOT NULL,
    [EffectiveDate]  DATE            NOT NULL,
    [ExpirationDate] DATE            NOT NULL,
    [IsCurrent]      BIT             NOT NULL,
    PRIMARY KEY CLUSTERED ([ExchangeRateId] ASC)
);


GO
PRINT N'Creating Table [prod].[DateDim]...';


GO
CREATE TABLE [prod].[DateDim] (
    [DateKey]    INT           NOT NULL,
    [FullDate]   DATE          NOT NULL,
    [Day]        INT           NOT NULL,
    [Month]      INT           NOT NULL,
    [MonthName]  NVARCHAR (20) NULL,
    [Year]       INT           NOT NULL,
    [Quarter]    INT           NOT NULL,
    [DayOfWeek]  INT           NOT NULL,
    [DayName]    NVARCHAR (20) NULL,
    [WeekOfYear] INT           NOT NULL,
    [ISOWeek]    INT           NULL,
    [IsWeekend]  BIT           NULL,
    [IsLeapYear] BIT           NULL,
    PRIMARY KEY CLUSTERED ([DateKey] ASC)
);


GO
PRINT N'Creating Table [prod].[ProductsDim]...';


GO
CREATE TABLE [prod].[ProductsDim] (
    [ProductId]       INT              IDENTITY (1, 1) NOT NULL,
    [Name]            NVARCHAR (255)   NOT NULL,
    [Description]     NVARCHAR (MAX)   NULL,
    [Color]           NVARCHAR (50)    NULL,
    [Brand]           NVARCHAR (100)   NULL,
    [Category]        NVARCHAR (100)   NULL,
    [Gender]          NVARCHAR (50)    NULL,
    [Price]           DECIMAL (10, 2)  NOT NULL,
    [BUSINESSKEYHASH] VARBINARY (6000) NULL,
    [HASHDATA]        VARCHAR (MAX)    NULL,
    [EffectiveDate]   DATETIME         NOT NULL,
    [ExpirationDate]  DATETIME         NOT NULL,
    [IsCurrent]       BIT              NOT NULL,
    PRIMARY KEY CLUSTERED ([ProductId] ASC)
);


GO
PRINT N'Creating Table [raw].[Products]...';


GO
CREATE TABLE [raw].[Products] (
    [ProductId]   INT             IDENTITY (1, 1) NOT NULL,
    [Name]        NVARCHAR (255)  NOT NULL,
    [Description] NVARCHAR (MAX)  NULL,
    [Color]       NVARCHAR (50)   NULL,
    [Brand]       NVARCHAR (100)  NULL,
    [Category]    NVARCHAR (100)  NULL,
    [Gender]      NVARCHAR (50)   NULL,
    [Price]       DECIMAL (10, 2) NOT NULL,
    [InsertedAt]  DATETIME        NULL,
    PRIMARY KEY CLUSTERED ([ProductId] ASC)
);


GO
PRINT N'Creating Table [raw].[Users]...';


GO
CREATE TABLE [raw].[Users] (
    [UserId]     INT            IDENTITY (1, 1) NOT NULL,
    [Source]     NVARCHAR (255) NULL,
    [UserJson]   NVARCHAR (MAX) NOT NULL,
    [InsertedAt] DATETIME       NULL,
    PRIMARY KEY CLUSTERED ([UserId] ASC)
);


GO
PRINT N'Creating Table [raw].[Transactions]...';


GO
CREATE TABLE [raw].[Transactions] (
    [TransactionId]   INT            IDENTITY (1, 1) NOT NULL,
    [TransactionJson] NVARCHAR (MAX) NULL,
    [InsertedAt]      DATETIME       NULL
);


GO
PRINT N'Creating Table [stage].[Products]...';


GO
CREATE TABLE [stage].[Products] (
    [ProductId]       INT              IDENTITY (1, 1) NOT NULL,
    [Name]            NVARCHAR (255)   NOT NULL,
    [Description]     NVARCHAR (MAX)   NULL,
    [Color]           NVARCHAR (50)    NULL,
    [Brand]           NVARCHAR (100)   NULL,
    [Category]        NVARCHAR (100)   NULL,
    [Gender]          NVARCHAR (50)    NULL,
    [Price]           DECIMAL (10, 2)  NOT NULL,
    [InsertedAt]      DATETIME         NULL,
    [BUSINESSKEYHASH] VARBINARY (6000) NULL,
    [HASHDATA]        VARCHAR (MAX)    NULL,
    PRIMARY KEY CLUSTERED ([ProductId] ASC)
);


GO
PRINT N'Creating Table [stage].[Transactions]...';


GO
CREATE TABLE [stage].[Transactions] (
    [TransactionId]            INT             IDENTITY (1, 1) NOT NULL,
    [TransactionBK]            NVARCHAR (50)   NULL,
    [UserId]                   INT             NULL,
    [Currency]                 NVARCHAR (3)    NULL,
    [ProductId]                INT             NULL,
    [ProductLocalPrice]        DECIMAL (18, 2) NULL,
    [ProductStandardizedPrice] DECIMAL (18, 2) NULL,
    [CartLocalPrice]           DECIMAL (18, 2) NULL,
    [CartStandardizedPrice]    DECIMAL (18, 2) NULL,
    [ExchangeRateId]           INT             NULL,
    [DateKey]                  INT             NULL,
    [InsertedAt]               DATETIME        NULL,
    PRIMARY KEY CLUSTERED ([TransactionId] ASC)
);


GO
PRINT N'Creating Table [stage].[SubTerritories]...';


GO
CREATE TABLE [stage].[SubTerritories] (
    [SubTerritoryId]  INT              IDENTITY (1, 1) NOT NULL,
    [TerritoryId]     INT              NOT NULL,
    [City]            NVARCHAR (100)   NOT NULL,
    [StreetName]      NVARCHAR (255)   NULL,
    [Latitude]        DECIMAL (9, 6)   NULL,
    [Longitude]       DECIMAL (9, 6)   NULL,
    [CreatedAt]       DATETIME         NULL,
    [BUSINESSKEYHASH] VARBINARY (6000) NULL,
    [HASHDATA]        VARCHAR (MAX)    NULL,
    PRIMARY KEY CLUSTERED ([SubTerritoryId] ASC)
);


GO
PRINT N'Creating Table [stage].[Territories]...';


GO
CREATE TABLE [stage].[Territories] (
    [TerritoryId]     INT              IDENTITY (1, 1) NOT NULL,
    [Country]         NVARCHAR (100)   NOT NULL,
    [State]           NVARCHAR (100)   NOT NULL,
    [CreatedAt]       DATETIME         NULL,
    [BUSINESSKEYHASH] VARBINARY (6000) NULL,
    [HASHDATA]        VARCHAR (MAX)    NULL,
    PRIMARY KEY CLUSTERED ([TerritoryId] ASC)
);


GO
PRINT N'Creating Table [stage].[Users]...';


GO
CREATE TABLE [stage].[Users] (
    [UserId]          INT              IDENTITY (1, 1) NOT NULL,
    [Source]          NVARCHAR (255)   NULL,
    [Gender]          CHAR (1)         NOT NULL,
    [FullName]        NVARCHAR (255)   NOT NULL,
    [FirstName]       NVARCHAR (100)   NOT NULL,
    [LastName]        NVARCHAR (100)   NOT NULL,
    [Email]           NVARCHAR (320)   NOT NULL,
    [InsertedAt]      DATETIME         NOT NULL,
    [SubTerritoryId]  INT              NOT NULL,
    [BUSINESSKEYHASH] VARBINARY (6000) NULL,
    [HASHDATA]        VARCHAR (MAX)    NULL,
    PRIMARY KEY CLUSTERED ([UserId] ASC)
);


GO
PRINT N'Creating Default Constraint unnamed constraint on [config].[CountryInfo]...';


GO
ALTER TABLE [config].[CountryInfo]
    ADD DEFAULT (getdate()) FOR [InsertedAt];


GO
PRINT N'Creating Default Constraint unnamed constraint on [config].[Datasets]...';


GO
ALTER TABLE [config].[Datasets]
    ADD DEFAULT (getdate()) FOR [CreatedAt];


GO
PRINT N'Creating Default Constraint unnamed constraint on [prod].[TransactionsFact]...';


GO
ALTER TABLE [prod].[TransactionsFact]
    ADD DEFAULT (getdate()) FOR [InsertedAt];


GO
PRINT N'Creating Default Constraint unnamed constraint on [prod].[UsersDim]...';


GO
ALTER TABLE [prod].[UsersDim]
    ADD DEFAULT ('9999-12-31') FOR [ExpirationDate];


GO
PRINT N'Creating Default Constraint unnamed constraint on [prod].[UsersDim]...';


GO
ALTER TABLE [prod].[UsersDim]
    ADD DEFAULT ((1)) FOR [IsCurrent];


GO
PRINT N'Creating Default Constraint unnamed constraint on [prod].[SubTerritoriesDim]...';


GO
ALTER TABLE [prod].[SubTerritoriesDim]
    ADD DEFAULT (getdate()) FOR [CreatedAt];


GO
PRINT N'Creating Default Constraint unnamed constraint on [prod].[TerritoriesDim]...';


GO
ALTER TABLE [prod].[TerritoriesDim]
    ADD DEFAULT (getdate()) FOR [CreatedAt];


GO
PRINT N'Creating Default Constraint unnamed constraint on [prod].[ExchangeRatesDim]...';


GO
ALTER TABLE [prod].[ExchangeRatesDim]
    ADD DEFAULT (getdate()) FOR [EffectiveDate];


GO
PRINT N'Creating Default Constraint unnamed constraint on [prod].[ExchangeRatesDim]...';


GO
ALTER TABLE [prod].[ExchangeRatesDim]
    ADD DEFAULT ('9999-12-31') FOR [ExpirationDate];


GO
PRINT N'Creating Default Constraint unnamed constraint on [prod].[ExchangeRatesDim]...';


GO
ALTER TABLE [prod].[ExchangeRatesDim]
    ADD DEFAULT ((1)) FOR [IsCurrent];


GO
PRINT N'Creating Default Constraint unnamed constraint on [prod].[ProductsDim]...';


GO
ALTER TABLE [prod].[ProductsDim]
    ADD DEFAULT (getdate()) FOR [EffectiveDate];


GO
PRINT N'Creating Default Constraint unnamed constraint on [prod].[ProductsDim]...';


GO
ALTER TABLE [prod].[ProductsDim]
    ADD DEFAULT ('9999-12-31') FOR [ExpirationDate];


GO
PRINT N'Creating Default Constraint unnamed constraint on [prod].[ProductsDim]...';


GO
ALTER TABLE [prod].[ProductsDim]
    ADD DEFAULT ((1)) FOR [IsCurrent];


GO
PRINT N'Creating Default Constraint unnamed constraint on [raw].[Products]...';


GO
ALTER TABLE [raw].[Products]
    ADD DEFAULT (getdate()) FOR [InsertedAt];


GO
PRINT N'Creating Default Constraint unnamed constraint on [raw].[Users]...';


GO
ALTER TABLE [raw].[Users]
    ADD DEFAULT ('https://randomuser.me/api/') FOR [Source];


GO
PRINT N'Creating Default Constraint unnamed constraint on [raw].[Users]...';


GO
ALTER TABLE [raw].[Users]
    ADD DEFAULT (getdate()) FOR [InsertedAt];


GO
PRINT N'Creating Default Constraint unnamed constraint on [raw].[Transactions]...';


GO
ALTER TABLE [raw].[Transactions]
    ADD DEFAULT (getdate()) FOR [InsertedAt];


GO
PRINT N'Creating Default Constraint unnamed constraint on [stage].[Products]...';


GO
ALTER TABLE [stage].[Products]
    ADD DEFAULT (getdate()) FOR [InsertedAt];


GO
PRINT N'Creating Default Constraint unnamed constraint on [stage].[Transactions]...';


GO
ALTER TABLE [stage].[Transactions]
    ADD DEFAULT (getdate()) FOR [InsertedAt];


GO
PRINT N'Creating Default Constraint unnamed constraint on [stage].[SubTerritories]...';


GO
ALTER TABLE [stage].[SubTerritories]
    ADD DEFAULT (getdate()) FOR [CreatedAt];


GO
PRINT N'Creating Default Constraint unnamed constraint on [stage].[Territories]...';


GO
ALTER TABLE [stage].[Territories]
    ADD DEFAULT (getdate()) FOR [CreatedAt];


GO
PRINT N'Creating Default Constraint unnamed constraint on [stage].[Users]...';


GO
ALTER TABLE [stage].[Users]
    ADD DEFAULT ('UNKNOWN') FOR [Source];


GO
PRINT N'Creating Default Constraint unnamed constraint on [stage].[Users]...';


GO
ALTER TABLE [stage].[Users]
    ADD DEFAULT (getdate()) FOR [InsertedAt];


GO
PRINT N'Creating Foreign Key [prod].[FK_TransactionsFact_Date]...';


GO
ALTER TABLE [prod].[TransactionsFact] WITH NOCHECK
    ADD CONSTRAINT [FK_TransactionsFact_Date] FOREIGN KEY ([DateKey]) REFERENCES [prod].[DateDim] ([DateKey]);


GO
PRINT N'Creating Foreign Key [prod].[FK_TransactionsFact_ExchangeRate]...';


GO
ALTER TABLE [prod].[TransactionsFact] WITH NOCHECK
    ADD CONSTRAINT [FK_TransactionsFact_ExchangeRate] FOREIGN KEY ([ExchangeRateId]) REFERENCES [prod].[ExchangeRatesDim] ([ExchangeRateId]);


GO
PRINT N'Creating Foreign Key [prod].[FK_TransactionsFact_Product]...';


GO
ALTER TABLE [prod].[TransactionsFact] WITH NOCHECK
    ADD CONSTRAINT [FK_TransactionsFact_Product] FOREIGN KEY ([ProductId]) REFERENCES [prod].[ProductsDim] ([ProductId]);


GO
PRINT N'Creating Foreign Key [prod].[FK_TransactionsFact_User]...';


GO
ALTER TABLE [prod].[TransactionsFact] WITH NOCHECK
    ADD CONSTRAINT [FK_TransactionsFact_User] FOREIGN KEY ([UserId]) REFERENCES [prod].[UsersDim] ([UserId]);


GO
PRINT N'Creating Foreign Key [prod].[FK_UsersDim_SubTerritories]...';


GO
ALTER TABLE [prod].[UsersDim] WITH NOCHECK
    ADD CONSTRAINT [FK_UsersDim_SubTerritories] FOREIGN KEY ([SubTerritoryId]) REFERENCES [prod].[SubTerritoriesDim] ([SubTerritoryId]);


GO
PRINT N'Creating Foreign Key [prod].[FK_SubTerritories_Territories]...';


GO
ALTER TABLE [prod].[SubTerritoriesDim] WITH NOCHECK
    ADD CONSTRAINT [FK_SubTerritories_Territories] FOREIGN KEY ([TerritoryId]) REFERENCES [prod].[TerritoriesDim] ([TerritoryId]);


GO
PRINT N'Creating Foreign Key [stage].[FK_StageTransactions_DateKey]...';


GO
ALTER TABLE [stage].[Transactions] WITH NOCHECK
    ADD CONSTRAINT [FK_StageTransactions_DateKey] FOREIGN KEY ([DateKey]) REFERENCES [prod].[DateDim] ([DateKey]);


GO
PRINT N'Creating Foreign Key [stage].[FK_StageTransactions_ExchangeRateId]...';


GO
ALTER TABLE [stage].[Transactions] WITH NOCHECK
    ADD CONSTRAINT [FK_StageTransactions_ExchangeRateId] FOREIGN KEY ([ExchangeRateId]) REFERENCES [prod].[ExchangeRatesDim] ([ExchangeRateId]);


GO
PRINT N'Creating Foreign Key [stage].[FK_StageTransactions_ProductId]...';


GO
ALTER TABLE [stage].[Transactions] WITH NOCHECK
    ADD CONSTRAINT [FK_StageTransactions_ProductId] FOREIGN KEY ([ProductId]) REFERENCES [prod].[ProductsDim] ([ProductId]);


GO
PRINT N'Creating Foreign Key [stage].[FK_StageTransactions_UserId]...';


GO
ALTER TABLE [stage].[Transactions] WITH NOCHECK
    ADD CONSTRAINT [FK_StageTransactions_UserId] FOREIGN KEY ([UserId]) REFERENCES [prod].[UsersDim] ([UserId]);


GO
PRINT N'Creating Foreign Key [stage].[FK_SubTerritories_Territories]...';


GO
ALTER TABLE [stage].[SubTerritories] WITH NOCHECK
    ADD CONSTRAINT [FK_SubTerritories_Territories] FOREIGN KEY ([TerritoryId]) REFERENCES [stage].[Territories] ([TerritoryId]);


GO
PRINT N'Creating Foreign Key [stage].[FK_StageUsers_SubTerritories]...';


GO
ALTER TABLE [stage].[Users] WITH NOCHECK
    ADD CONSTRAINT [FK_StageUsers_SubTerritories] FOREIGN KEY ([SubTerritoryId]) REFERENCES [stage].[SubTerritories] ([SubTerritoryId]);


GO
PRINT N'Creating View [utils].[GetTerritoryCurrencies]...';


GO
CREATE   VIEW utils.GetTerritoryCurrencies AS
SELECT DISTINCT
    td.Country [Country],
    ci.Currency [Currency]
FROM
    prod.TerritoriesDim td
JOIN config.CountryInfo ci 
	ON td.Country = ci.CountryName;
GO
PRINT N'Creating Procedure [config].[IngestCountryInfo]...';


GO
CREATE PROCEDURE [config].[IngestCountryInfo]
    @CountryName NVARCHAR(255),
    @Currency NVARCHAR(10),
    @CurrencySymbol NVARCHAR(100)
AS
BEGIN
    SET NOCOUNT ON;

    IF OBJECT_ID('[config].[CountryInfo]', 'U') IS NULL
    BEGIN
        CREATE TABLE [config].[CountryInfo]
		(
			Id INT IDENTITY(1,1) PRIMARY KEY,
			CountryName NVARCHAR(255),
			Currency NVARCHAR(10),
			CurrencySymbol NVARCHAR(10),
			InsertedAt DATETIME DEFAULT GETDATE()
		);
    END

    -- Insert or ignore if already exists (optional logic depending on uniqueness)
    INSERT INTO [config].[CountryInfo] (
		CountryName,
		Currency,
		CurrencySymbol
	)
	VALUES (
		@CountryName,
		@Currency,
		@CurrencySymbol
	)
END
GO
PRINT N'Creating Procedure [config].[HashTableEntries]...';


GO
CREATE   PROCEDURE config.HashTableEntries
    @DataSourceID INT
AS
BEGIN
    SET NOCOUNT ON;

    BEGIN TRY
        
        DECLARE @sqlHashData NVARCHAR(MAX);
        DECLARE @HashString NVARCHAR(MAX);

        -- Get the target processing table from the Datasets config
        DECLARE @TableAndSchema NVARCHAR(MAX) = (SELECT d.ProcessingTable FROM config.Datasets d WHERE d.Id = @DataSourceID)

        IF @TableAndSchema IS NULL
        BEGIN
            RAISERROR('No processing table found for DataSourceID %d.', 16, 1, @DataSourceID);
            RETURN;
        END;

        -- Construct the hash string from the HashColumns config
        WITH HC AS (
            SELECT TOP 100 PERCENT HashString
            FROM config.HashColumns
            WHERE DatasetId = @DataSourceID
            ORDER BY HashOrder, Id
        )
        SELECT @HashString = STRING_AGG(HashString, ', ''|'' , ')
        FROM HC;

        IF @HashString IS NULL
        BEGIN
            RAISERROR('No hash columns found for DataSourceID %d.', 16, 1, @DataSourceID);
            RETURN;
        END

        -- Prepare dynamic SQL
        SET @sqlHashData = '
            UPDATE ' + @TableAndSchema + '
            SET HASHDATA = UPPER(CONCAT(' + @HashString + '));

            UPDATE ' + @TableAndSchema + '
            SET BUSINESSKEYHASH = HASHBYTES(''SHA2_512'', HASHDATA);
        ';

        -- Execute the dynamic SQL
        EXEC sp_executesql @sqlHashData;

    END TRY
    BEGIN CATCH
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();

        RAISERROR('Error in config.HashTableEntries: %s', @ErrorSeverity, @ErrorState, @ErrorMessage);
    END CATCH
END;
GO
PRINT N'Creating Procedure [prod].[UpsertProductsDim]...';


GO
CREATE   PROCEDURE [prod].[UpsertProductsDim]
AS
BEGIN
    SET NOCOUNT ON;

    BEGIN TRY
        BEGIN TRANSACTION;

        -- Step 1: Expire old records if BUSINESSKEYHASH exists in both stage and prod
        UPDATE p
        SET 
            ExpirationDate = GETDATE(),
            IsCurrent = 0
        FROM prod.ProductsDim p
        INNER JOIN stage.Products s
            ON p.BUSINESSKEYHASH = s.BUSINESSKEYHASH AND p.Price <> s.Price
        WHERE p.IsCurrent = 1;

        INSERT INTO prod.ProductsDim (
            Name,
            Description,
            Color,
            Brand,
            Category,
            Gender,
            Price,
            BUSINESSKEYHASH,
            HASHDATA,
			EffectiveDate
        )
        SELECT 
            s.Name,
            s.Description,
            s.Color,
            s.Brand,
            s.Category,
            s.Gender,
            s.Price,
            s.BUSINESSKEYHASH,
            s.HASHDATA,
			InsertedAt
        FROM stage.Products s
		WHERE NOT EXISTS (
            SELECT 1
            FROM prod.ProductsDim p
            WHERE 
                p.BUSINESSKEYHASH = s.BUSINESSKEYHASH
                AND p.IsCurrent = 1
        );

        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;
        DECLARE @ErrorMessage NVARCHAR(MAX) = ERROR_MESSAGE();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();
        RAISERROR (@ErrorMessage, @ErrorSeverity, @ErrorState);
    END CATCH
END;
GO
PRINT N'Creating Procedure [prod].[UpsertExchangeRate]...';


GO
CREATE   PROCEDURE [prod].[UpsertExchangeRate]
    @Country NVARCHAR(255),
    @Currency NVARCHAR(10),
    @RateToEUR DECIMAL(18,6)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @Today DATE = CAST(GETDATE() AS DATE);

    -- Deactivate previous rows for this currency
    UPDATE prod.ExchangeRatesDim
    SET 
		IsCurrent = 0,
        ExpirationDate = @Today
    WHERE
		Country = @Country
		AND Currency = @Currency 
		AND IsCurrent = 1;

    INSERT INTO prod.ExchangeRatesDim 
	(
        Country,
		Currency,
		RateToEUR
    )
    VALUES (
        @Country,
		@Currency,
		@RateToEUR
    );
END
GO
PRINT N'Creating Procedure [prod].[InsertTransactionsFact]...';


GO
CREATE   PROCEDURE prod.InsertTransactionsFact
AS
BEGIN
    SET NOCOUNT ON;

    BEGIN TRY
        -- If the table does not exist, create it
        IF NOT EXISTS (
            SELECT 1
            FROM INFORMATION_SCHEMA.TABLES
            WHERE TABLE_SCHEMA = 'prod' AND TABLE_NAME = 'TransactionsFact'
        )
        BEGIN
            EXEC('
                CREATE TABLE prod.TransactionsFact (
                    TransactionId INT IDENTITY(1,1) PRIMARY KEY,
                    TransactionBK NVARCHAR(50) NOT NULL,
                    UserId INT NOT NULL,
                    ProductId INT NOT NULL,
                    ExchangeRateId INT NOT NULL,
                    DateKey INT NOT NULL,
                    Currency NVARCHAR(3) NOT NULL,
                    ProductLocalPrice DECIMAL(18, 2) NOT NULL,
                    ProductStandardizedPrice DECIMAL(18, 2) NOT NULL,
                    CartLocalPrice DECIMAL(18, 2) NOT NULL,
                    CartStandardizedPrice DECIMAL(18, 2) NOT NULL,
                    InsertedAt DATETIME DEFAULT GETDATE(),

                    CONSTRAINT FK_TransactionsFact_User FOREIGN KEY (UserId) REFERENCES prod.UsersDim(UserId),
                    CONSTRAINT FK_TransactionsFact_Product FOREIGN KEY (ProductId) REFERENCES prod.ProductsDim(ProductId),
                    CONSTRAINT FK_TransactionsFact_ExchangeRate FOREIGN KEY (ExchangeRateId) REFERENCES prod.ExchangeRatesDim(ExchangeRateId),
                    CONSTRAINT FK_TransactionsFact_Date FOREIGN KEY (DateKey) REFERENCES prod.DateDim(DateKey)
                );
            ');
        END

        -- Insert data into prod.TransactionsFact
        INSERT INTO prod.TransactionsFact (
            TransactionBK,
            UserId,
            ProductId,
            ExchangeRateId,
            DateKey,
            Currency,
            ProductLocalPrice,
            ProductStandardizedPrice,
            CartLocalPrice,
            CartStandardizedPrice,
            InsertedAt
        )
        SELECT
            TransactionBK,
            UserId,
            ProductId,
            ExchangeRateId,
            DateKey,
            Currency,
            ProductLocalPrice,
            ProductStandardizedPrice,
            CartLocalPrice,
            CartStandardizedPrice,
            InsertedAt
        FROM stage.Transactions;

    END TRY
    BEGIN CATCH
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        RAISERROR('Error in InsertTransactionsFact: %s', 16, 1, @ErrorMessage);
    END CATCH
END;
GO
PRINT N'Creating Procedure [prod].[GenerateDateDim]...';


GO
CREATE PROCEDURE [prod].[GenerateDateDim]
    @StartDate DATE,
    @EndDate DATE
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @CurrentDate DATE = @StartDate;

    WHILE @CurrentDate <= @EndDate
    BEGIN
        INSERT INTO prod.DateDim (
            DateKey, FullDate, Day, Month, MonthName, Year, Quarter,
            DayOfWeek, DayName, WeekOfYear, ISOWeek, IsWeekend, IsLeapYear
        )
        SELECT
            CONVERT(INT, FORMAT(@CurrentDate, 'yyyyMMdd')),
            @CurrentDate,
            DAY(@CurrentDate),
            MONTH(@CurrentDate),
            DATENAME(MONTH, @CurrentDate),
            YEAR(@CurrentDate),
            DATEPART(QUARTER, @CurrentDate),
            DATEPART(WEEKDAY, @CurrentDate),
            DATENAME(WEEKDAY, @CurrentDate),
            DATEPART(WEEK, @CurrentDate),
            DATEPART(ISO_WEEK, @CurrentDate),
            CASE WHEN DATEPART(WEEKDAY, @CurrentDate) IN (1, 7) THEN 1 ELSE 0 END,
            CASE WHEN (YEAR(@CurrentDate) % 4 = 0 AND YEAR(@CurrentDate) % 100 <> 0) OR (YEAR(@CurrentDate) % 400 = 0) THEN 1 ELSE 0 END;

        SET @CurrentDate = DATEADD(DAY, 1, @CurrentDate);
    END
END;
GO
PRINT N'Creating Procedure [prod].[UpsertUsersDim]...';


GO

CREATE PROCEDURE [prod].[UpsertUsersDim]
AS
BEGIN
    SET NOCOUNT ON;

    BEGIN TRY
        BEGIN TRANSACTION;

        -- Materialize the CTE as a temp table
        IF OBJECT_ID('tempdb..#UsersWithProdTerritory') IS NOT NULL
            DROP TABLE #UsersWithProdSubTerritory;

        SELECT 
            su.*,
            std.SubTerritoryId AS ProdSubTerritoryId
        INTO #UsersWithProdSubTerritory
        FROM 
            stage.Users su
        INNER JOIN stage.SubTerritories st
            ON su.SubTerritoryId = st.SubTerritoryId
		INNER JOIN prod.SubTerritoriesDim std
			ON st.City = std.City
			AND st.StreetName = std.StreetName
			AND st.Latitude = std.Latitude
			AND st.Longitude = std.Longitude
		
		-- Step 1: Expire old records where Email has changed
        UPDATE d
        SET 
            d.ExpirationDate = s.InsertedAt,
            d.IsCurrent = 0
        FROM prod.UsersDim d
        INNER JOIN #UsersWithProdSubTerritory s 
			ON d.BUSINESSKEYHASH = s.BUSINESSKEYHASH
        WHERE 
            d.IsCurrent = 1
            AND ISNULL(d.Email, '') <> ISNULL(s.Email, '');

        -- Step 2: Insert new or changed records
        INSERT INTO prod.UsersDim (
            Source, 
			Gender,
			FullName,
			FirstName,
			LastName,
			Email,
			SubTerritoryId,
            BUSINESSKEYHASH,
			HASHDATA,
            EffectiveDate,
			ExpirationDate,
			IsCurrent
        )
        SELECT 
            s.Source,
            s.Gender,
            s.FullName,
            s.FirstName,
            s.LastName,
            s.Email,
            s.ProdSubTerritoryId,
            s.BUSINESSKEYHASH,
            s.HASHDATA,
            s.InsertedAt AS EffectiveDate,
            '9999-12-31' AS ExpirationDate,
            1 AS IsCurrent
        FROM #UsersWithProdSubTerritory s
        LEFT JOIN prod.UsersDim d
            ON s.BUSINESSKEYHASH = d.BUSINESSKEYHASH 
			AND d.IsCurrent = 1
        WHERE 
            d.UserId IS NULL 
			OR ISNULL(d.Email, '') <> ISNULL(s.Email, '');

        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;

        DECLARE @ErrorMessage NVARCHAR(MAX) = ERROR_MESSAGE();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();

        RAISERROR (@ErrorMessage, @ErrorSeverity, @ErrorState);
    END CATCH
END;
GO
PRINT N'Creating Procedure [prod].[MergeSubTerritoriesDim]...';


GO
CREATE   PROCEDURE [prod].[MergeSubTerritoriesDim]
AS
BEGIN
    SET NOCOUNT ON;

    BEGIN TRY
        BEGIN TRANSACTION;

        MERGE INTO prod.SubTerritoriesDim AS target
        USING (
            SELECT 
                b.TerritoryId,
                a.City,
                a.StreetName,
                a.Latitude,
                a.Longitude,
                a.CreatedAt,
                a.BUSINESSKEYHASH,
                a.HASHDATA
            FROM stage.SubTerritories a
            INNER JOIN stage.Territories t ON a.TerritoryId = t.TerritoryId
            INNER JOIN prod.TerritoriesDim b ON t.BUSINESSKEYHASH = b.BUSINESSKEYHASH
        ) AS source
        ON target.BUSINESSKEYHASH = source.BUSINESSKEYHASH

        WHEN NOT MATCHED BY TARGET THEN
            INSERT (TerritoryId, City, StreetName, Latitude, Longitude, CreatedAt, BUSINESSKEYHASH, HASHDATA)
            VALUES (source.TerritoryId, source.City, source.StreetName, source.Latitude, source.Longitude, GETDATE(), source.BUSINESSKEYHASH, source.HASHDATA);

        -- No update on match, no delete

        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;

        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();

        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
    END CATCH
END;
GO
PRINT N'Creating Procedure [prod].[MergeTerritoriesDim]...';


GO
CREATE   PROCEDURE [prod].[MergeTerritoriesDim]
AS
BEGIN
    SET NOCOUNT ON;

    BEGIN TRY
        BEGIN TRANSACTION;

        MERGE INTO prod.TerritoriesDim AS target
        USING (
            SELECT Country, State, BUSINESSKEYHASH, HASHDATA
            FROM stage.Territories
        ) AS source
        ON target.BUSINESSKEYHASH = source.BUSINESSKEYHASH

        WHEN NOT MATCHED BY TARGET THEN
            INSERT (Country, State, CreatedAt, BUSINESSKEYHASH, HASHDATA)
            VALUES (source.Country, source.State, GETDATE(), source.BUSINESSKEYHASH, source.HASHDATA);

        -- No update on match, no delete

        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;

        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();

        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
    END CATCH
END;
GO
PRINT N'Creating Procedure [raw].[IngestRawProducts]...';


GO
CREATE   PROCEDURE [raw].[IngestRawProducts]
    @Name NVARCHAR(255),
    @Description NVARCHAR(MAX),
    @Color NVARCHAR(50),
    @Brand NVARCHAR(100),
    @Category NVARCHAR(100),
    @Gender NVARCHAR(50),
    @Price DECIMAL(10, 2)
AS
BEGIN
    SET NOCOUNT ON;

    IF OBJECT_ID('[raw].[Products]', 'U') IS NULL
    BEGIN
        CREATE TABLE [raw].[Products] (
            ProductId INT IDENTITY(1,1) PRIMARY KEY,
            Name NVARCHAR(255) NOT NULL,
            Description NVARCHAR(MAX) NULL,
            Color NVARCHAR(50) NULL,
            Brand NVARCHAR(100) NULL,
            Category NVARCHAR(100) NULL,
            Gender NVARCHAR(50) NULL,
            Price DECIMAL(10, 2) NOT NULL,
            InsertedAt DATETIME DEFAULT GETDATE()
        );
    END

    INSERT INTO [raw].[Products] (Name, Description, Color, Brand, Category, Gender, Price)
    VALUES (@Name, @Description, @Color, @Brand, @Category, @Gender, @Price);
END
GO
PRINT N'Creating Procedure [raw].[IngestRawUsers]...';


GO
CREATE PROCEDURE [raw].[IngestRawUsers]
    @UserJson NVARCHAR(MAX),
    @Source NVARCHAR(255) = 'https://randomuser.me/api/'
AS
BEGIN
    SET NOCOUNT ON;

    IF OBJECT_ID('[raw].[Users]', 'U') IS NULL
    BEGIN
        CREATE TABLE [raw].[Users]
        (
            [UserId] INT IDENTITY(1,1) PRIMARY KEY,
            [Source] NVARCHAR(255) NULL DEFAULT 'https://randomuser.me/api/',
            [UserJson] NVARCHAR(MAX) NOT NULL,
			[InsertedAt] DATETIME DEFAULT GETDATE()
        );

    END

    INSERT INTO [raw].[Users] (UserJson, Source)
    VALUES (@UserJson, @Source);
END
GO
PRINT N'Creating Procedure [raw].[IngestRawTransactions]...';


GO
CREATE PROCEDURE [raw].[IngestRawTransactions]
    @TransactionJson NVARCHAR(MAX)
AS
BEGIN
    SET NOCOUNT ON;

    IF OBJECT_ID('[raw].[Transactions]', 'U') IS NULL
    BEGIN
		CREATE TABLE [raw].[Transactions] (
			[TransactionId] INT IDENTITY(1,1),
			[TransactionJson] NVARCHAR(MAX),
			[InsertedAt] DATETIME DEFAULT GETDATE()
		);
    END

    INSERT INTO [raw].[Transactions] (TransactionJson)
    VALUES (@TransactionJson);
END
GO
PRINT N'Creating Procedure [stage].[ProcessRawProducts]...';


GO
CREATE PROCEDURE [stage].[ProcessRawProducts]
AS
BEGIN
    SET NOCOUNT ON;

    BEGIN TRY
        BEGIN TRANSACTION;

        -- Step 1: Create the stage.Products table if it does not exist
        IF OBJECT_ID('[stage].[Products]', 'U') IS NULL
        BEGIN
            CREATE TABLE [stage].[Products] (
                ProductId INT IDENTITY(1,1) PRIMARY KEY,
                Name NVARCHAR(255) NOT NULL,
                Description NVARCHAR(MAX) NULL,
                Color NVARCHAR(50) NULL,
                Brand NVARCHAR(100) NULL,
                Category NVARCHAR(100) NULL,
                Gender NVARCHAR(50) NULL,
                Price DECIMAL(10, 2) NOT NULL,
                InsertedAt DATETIME DEFAULT GETDATE(),
                BUSINESSKEYHASH VARBINARY(6000) NULL,
                HASHDATA VARCHAR(MAX) NULL
            );
        END
        ELSE
        BEGIN
            -- Step 2: Truncate existing stage table
            TRUNCATE TABLE [stage].[Products];
        END

        INSERT INTO [stage].[Products] (
			Name,
			Description,
			Color,
			Brand,
			Category,
			Gender,
			Price
		)
		SELECT
			r.[Name],
			r.[Description],
			r.Color,
			r.Brand,
			r.Category,
			r.Gender,
			r.Price
		FROM 
			[raw].[Products] r
		WHERE NOT EXISTS (
			SELECT 1
			FROM 
				[stage].[Products] s
			WHERE s.Name = r.Name
				AND s.Brand = r.Brand
				AND s.Category = r.Category
				AND s.Color = r.Color
				AND s.Gender = r.Gender
				AND s.Price = r.Price
		);

        -- Step 4: Call hashing stored procedure
        EXEC config.HashTableEntries @DataSourceId = 5;

        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;

        DECLARE @ErrorMessage NVARCHAR(MAX) = ERROR_MESSAGE();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();

        RAISERROR (@ErrorMessage, @ErrorSeverity, @ErrorState);
    END CATCH
END;
GO
PRINT N'Creating Procedure [stage].[ProcessRawTransactions]...';


GO
CREATE   PROCEDURE [stage].[ProcessRawTransactions]
AS
BEGIN
    SET NOCOUNT ON;

    BEGIN TRY
		TRUNCATE TABLE [stage].[Transactions];

        DECLARE 
            @TransactionId INT,
            @TransactionJson NVARCHAR(MAX),
            @InsertedAt DATETIME,
            @UserEmail NVARCHAR(320),
            @TransactionDate DATE,
            @Country NVARCHAR(100),
            @Cart NVARCHAR(MAX),

            @ProductName NVARCHAR(255),
            @ProductLocalPrice DECIMAL(18,2),
            @UserId INT,
            @ProductId INT,
            @CurrencyCode NVARCHAR(10),
            @ExchangeRateToEUR DECIMAL(18,6),
            @ExchangeRateId INT,
            @DateKey INT,

            @CartLocalTotal DECIMAL(18,2),
            @CartStandardizedTotal DECIMAL(18,2),

            @TransactionBK NVARCHAR(50),
            @TransactionDateStr NVARCHAR(8),
            @NextSequence INT = NULL;

        DECLARE TransactionCursor CURSOR FOR
            SELECT TransactionId, TransactionJson, InsertedAt
            FROM raw.Transactions
            ORDER BY InsertedAt;

        OPEN TransactionCursor;
        FETCH NEXT FROM TransactionCursor INTO @TransactionId, @TransactionJson, @InsertedAt;

		SET @TransactionDateStr = FORMAT(@TransactionDate, 'yyyyMMdd');

		SELECT @NextSequence = ISNULL(MAX(CAST(RIGHT(TransactionBK, 5) AS INT)), 0)
		FROM prod.TransactionsFact
		WHERE TransactionBK LIKE CONCAT('ORD', @TransactionDateStr, '%');

		DECLARE @CartItems TABLE (
            ProductName NVARCHAR(255),
            ProductLocalPrice DECIMAL(18,2)
        );

        WHILE @@FETCH_STATUS = 0
        BEGIN
			DELETE FROM @CartItems;

            SET @CartLocalTotal = 0;
            SET @CartStandardizedTotal = 0;

            SET @UserEmail = JSON_VALUE(@TransactionJson, '$.UserEmail');
            SET @TransactionDate = TRY_CAST(JSON_VALUE(@TransactionJson, '$.Date') AS DATE);
            SET @Cart = JSON_QUERY(@TransactionJson, '$.Cart');

            IF @UserEmail IS NULL OR @TransactionDate IS NULL
            BEGIN
                FETCH NEXT FROM TransactionCursor INTO @TransactionId, @TransactionJson, @InsertedAt;
                CONTINUE;
            END

            SELECT @Country = JSON_VALUE(TransactionJson, '$.Country')
            FROM raw.Transactions
            WHERE TransactionId = @TransactionId;

            SELECT @UserId = UserId
            FROM prod.UsersDim
            WHERE Email COLLATE SQL_Latin1_General_CP1_CI_AS = @UserEmail COLLATE SQL_Latin1_General_CP1_CI_AS
              AND IsCurrent = 1;

            IF @UserId IS NULL
            BEGIN
                FETCH NEXT FROM TransactionCursor INTO @TransactionId, @TransactionJson, @InsertedAt;
                CONTINUE;
            END

            SELECT @CurrencyCode = Currency
            FROM config.CountryInfo
            WHERE CountryName = @Country;

            IF @CurrencyCode IS NULL
            BEGIN
                FETCH NEXT FROM TransactionCursor INTO @TransactionId, @TransactionJson, @InsertedAt;
                CONTINUE;
            END

            -- Get latest exchange rate info
            SELECT TOP 1 
                @ExchangeRateToEUR = RateToEUR,
                @ExchangeRateId = ExchangeRateId
            FROM prod.ExchangeRatesDim
            WHERE Currency = @CurrencyCode AND IsCurrent = 1;

            IF @ExchangeRateToEUR IS NULL OR @ExchangeRateToEUR = 0
            BEGIN
                FETCH NEXT FROM TransactionCursor INTO @TransactionId, @TransactionJson, @InsertedAt;
                CONTINUE;
            END

            -- Get DateKey
            SELECT @DateKey = DateKey
            FROM prod.DateDim
            WHERE FullDate = @TransactionDate;

            IF @DateKey IS NULL
            BEGIN
                FETCH NEXT FROM TransactionCursor INTO @TransactionId, @TransactionJson, @InsertedAt;
                CONTINUE;
            END

			SET @NextSequence += 1;

			SET @TransactionBK = CONCAT('ORD', @TransactionDateStr, '-', RIGHT('00000' + CAST(@NextSequence AS NVARCHAR(5)), 5));

            INSERT INTO @CartItems(ProductName, ProductLocalPrice)
            SELECT 
                cart_key_value.[key],
                TRY_CAST(cart_key_value.[value] AS DECIMAL(18,2))
            FROM (SELECT @TransactionJson AS TransactionJson) AS r
            CROSS APPLY OPENJSON(r.TransactionJson, '$.Cart') AS cart_item
            CROSS APPLY OPENJSON(cart_item.value) AS cart_key_value;

            DECLARE CartCursor CURSOR FOR
                SELECT ProductName, ProductLocalPrice FROM @CartItems;

            OPEN CartCursor;
            FETCH NEXT FROM CartCursor INTO @ProductName, @ProductLocalPrice;

            WHILE @@FETCH_STATUS = 0
            BEGIN
                SELECT @ProductId = ProductId
                FROM prod.ProductsDim
                WHERE Name = @ProductName AND @ProductLocalPrice = Price AND IsCurrent = 1;

                IF @ProductId IS NULL
                BEGIN
                    FETCH NEXT FROM CartCursor INTO @ProductName, @ProductLocalPrice;
                    CONTINUE;
                END

                DECLARE @ProductStandardizedPrice DECIMAL(18,2) = ROUND(ISNULL(@ProductLocalPrice,0) * NULLIF(@ExchangeRateToEUR,0), 2);

                SET @CartLocalTotal += ISNULL(@ProductLocalPrice, 0);
                SET @CartStandardizedTotal += @ProductStandardizedPrice;

                INSERT INTO stage.Transactions (
                    TransactionBK,
                    UserId,
                    Currency,
                    ProductId,
                    ProductLocalPrice,
                    ProductStandardizedPrice,
                    CartLocalPrice,
                    CartStandardizedPrice,
                    ExchangeRateId,
                    DateKey,
                    InsertedAt
                )
                VALUES (
                    @TransactionBK,
                    @UserId,
                    @CurrencyCode,
                    @ProductId,
                    @ProductLocalPrice,
                    @ProductStandardizedPrice,
                    0,
                    0,
                    @ExchangeRateId,
                    @DateKey,
                    @InsertedAt
                );

                FETCH NEXT FROM CartCursor INTO @ProductName, @ProductLocalPrice;
            END

            CLOSE CartCursor;
            DEALLOCATE CartCursor;

            UPDATE stage.Transactions
            SET CartLocalPrice = @CartLocalTotal,
                CartStandardizedPrice = @CartStandardizedTotal
            WHERE TransactionBK = @TransactionBK;

            FETCH NEXT FROM TransactionCursor INTO @TransactionId, @TransactionJson, @InsertedAt;
        END

        CLOSE TransactionCursor;
        DEALLOCATE TransactionCursor;

    END TRY
    BEGIN CATCH
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        RAISERROR('Error in stage.ProcessRawTransactions: %s', 16, 1, @ErrorMessage);
    END CATCH;
END;
GO
PRINT N'Creating Procedure [stage].[ProcessSubTerritories]...';


GO
CREATE PROCEDURE [stage].[ProcessSubTerritories]
    @IsSuccess BIT OUTPUT,
    @ErrorMessage NVARCHAR(MAX) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

    BEGIN TRY
        -- Insert distinct subterritories
        INSERT INTO stage.SubTerritories (
            TerritoryId, City, StreetName, Latitude, Longitude
        )
        SELECT DISTINCT
            t.TerritoryId,
            pu.City,
            pu.StreetName,
            pu.Latitude,
            pu.Longitude
        FROM #ParsedUsers pu
        INNER JOIN stage.Territories t
            ON pu.Country = t.Country AND pu.State = t.State
        WHERE NOT EXISTS (
            SELECT 1
            FROM stage.SubTerritories st
            WHERE st.TerritoryId = t.TerritoryId
              AND st.City = pu.City
              AND ISNULL(st.StreetName, '') = ISNULL(pu.StreetName, '')
              AND ISNULL(st.Latitude, 0) = ISNULL(pu.Latitude, 0)
              AND ISNULL(st.Longitude, 0) = ISNULL(pu.Longitude, 0)
        );

		EXEC config.HashTableEntries @DataSourceId = 3;

		EXEC [prod].[MergeSubTerritoriesDim];

        SET @IsSuccess = 1;
        SET @ErrorMessage = NULL;
    END TRY
    BEGIN CATCH
        SET @IsSuccess = 0;
        SET @ErrorMessage = ERROR_MESSAGE();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
    END CATCH
END;
GO
PRINT N'Creating Procedure [stage].[ProcessTerritories]...';


GO
CREATE PROCEDURE [stage].[ProcessTerritories]
    @IsSuccess BIT OUTPUT,
    @ErrorMessage NVARCHAR(MAX) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

    BEGIN TRY
        -- Insert distinct values from #ParsedUsers
        INSERT INTO stage.Territories (Country, State)
        SELECT DISTINCT
            pu.Country,
            pu.State
        FROM #ParsedUsers pu
        WHERE NOT EXISTS (
            SELECT 1
            FROM stage.Territories t
            WHERE t.Country = pu.Country AND t.State = pu.State
        );

		EXEC config.HashTableEntries @DataSourceId = 2;

		EXEC [prod].[MergeTerritoriesDim];

        SET @IsSuccess = 1;
        SET @ErrorMessage = NULL;
    END TRY
    BEGIN CATCH
        SET @IsSuccess = 0;
        SET @ErrorMessage = ERROR_MESSAGE();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
    END CATCH
END;
GO
PRINT N'Creating Procedure [stage].[ProcessRawUsers]...';


GO


CREATE PROCEDURE [stage].[ProcessRawUsers]
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @TerritorySuccess BIT, @TerritoryError NVARCHAR(MAX);
    DECLARE @SubTerritorySuccess BIT, @SubTerritoryError NVARCHAR(MAX);

    BEGIN TRY
        BEGIN TRANSACTION;

		TRUNCATE TABLE [stage].[Users];

        IF OBJECT_ID('tempdb..#ParsedUsers') IS NOT NULL DROP TABLE #ParsedUsers;

        CREATE TABLE #ParsedUsers (
            Source NVARCHAR(255),
            Gender CHAR(1),
            FullName NVARCHAR(255),
            FirstName NVARCHAR(100),
            LastName NVARCHAR(100),
            Email NVARCHAR(320),
            Country NVARCHAR(100),
            State NVARCHAR(100),
            City NVARCHAR(100),
            StreetName NVARCHAR(255),
            Latitude DECIMAL(9,6) NULL,
            Longitude DECIMAL(9,6) NULL,
            InsertedAt DATETIME
        );

        INSERT INTO #ParsedUsers (
            Source, Gender, FullName, FirstName, LastName, Email,
            Country, State, City, StreetName, Latitude, Longitude, InsertedAt
        )
        SELECT
            u.Source,
            CASE LOWER(JSON_VALUE(u.UserJson, '$.gender'))
                WHEN 'male' THEN 'M'
                WHEN 'female' THEN 'F'
                ELSE NULL
            END,
            JSON_VALUE(u.UserJson, '$.name.first') + ' ' + JSON_VALUE(u.UserJson, '$.name.last'),
            JSON_VALUE(u.UserJson, '$.name.first'),
            JSON_VALUE(u.UserJson, '$.name.last'),
            JSON_VALUE(u.UserJson, '$.email'),
            JSON_VALUE(u.UserJson, '$.location.country'),
            JSON_VALUE(u.UserJson, '$.location.state'),
            JSON_VALUE(u.UserJson, '$.location.city'),
            JSON_VALUE(u.UserJson, '$.location.street.name'),
            TRY_CAST(JSON_VALUE(u.UserJson, '$.location.coordinates.latitude') AS DECIMAL(9,6)),
            TRY_CAST(JSON_VALUE(u.UserJson, '$.location.coordinates.longitude') AS DECIMAL(9,6)),
            u.InsertedAt
        FROM raw.Users u
        WHERE 
            ISNULL(JSON_VALUE(u.UserJson, '$.name.first'), '') COLLATE Latin1_General_BIN NOT LIKE '%[^ -~]%' AND
            ISNULL(JSON_VALUE(u.UserJson, '$.name.last'), '') COLLATE Latin1_General_BIN NOT LIKE '%[^ -~]%' AND
            ISNULL(JSON_VALUE(u.UserJson, '$.location.city'), '') COLLATE Latin1_General_BIN NOT LIKE '%[^ -~]%' AND
            ISNULL(JSON_VALUE(u.UserJson, '$.location.state'), '') COLLATE Latin1_General_BIN NOT LIKE '%[^ -~]%';

		DELETE FROM stage.SubTerritories;
		DELETE FROM stage.Territories;


        -- Process Territories
        EXEC [stage].[ProcessTerritories]
            @IsSuccess = @TerritorySuccess OUTPUT,
            @ErrorMessage = @TerritoryError OUTPUT;

        IF @TerritorySuccess = 0
        BEGIN
            RAISERROR(@TerritoryError, 16, 1);
        END

        -- Process SubTerritories
        EXEC [stage].[ProcessSubTerritories]
            @IsSuccess = @SubTerritorySuccess OUTPUT,
            @ErrorMessage = @SubTerritoryError OUTPUT;

        IF @SubTerritorySuccess = 0
        BEGIN
            RAISERROR(@SubTerritoryError, 16, 1);
        END

        -- Final user load
        INSERT INTO stage.Users (
            Source, Gender, FullName, FirstName, LastName, Email, InsertedAt, SubTerritoryId
        )
        SELECT
            pu.Source,
            pu.Gender,
            pu.FullName,
            pu.FirstName,
            pu.LastName,
            pu.Email,
            pu.InsertedAt,
            st.SubTerritoryId
        FROM #ParsedUsers pu
        INNER JOIN stage.Territories t
            ON pu.Country = t.Country AND pu.State = t.State
        INNER JOIN stage.SubTerritories st
            ON t.TerritoryId = st.TerritoryId
           AND st.City = pu.City
           AND ISNULL(st.StreetName, '') = ISNULL(pu.StreetName, '')
           AND ISNULL(st.Latitude, 0) = ISNULL(pu.Latitude, 0)
           AND ISNULL(st.Longitude, 0) = ISNULL(pu.Longitude, 0);

        EXEC config.HashTableEntries @DataSourceId = 1;

		EXEC prod.UpsertUsersDim;

        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;
        DECLARE @ErrorMessage NVARCHAR(MAX) = ERROR_MESSAGE();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();
        RAISERROR (@ErrorMessage, @ErrorSeverity, @ErrorState);
    END CATCH
END;
GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [prod].[TransactionsFact] WITH CHECK CHECK CONSTRAINT [FK_TransactionsFact_Date];

ALTER TABLE [prod].[TransactionsFact] WITH CHECK CHECK CONSTRAINT [FK_TransactionsFact_ExchangeRate];

ALTER TABLE [prod].[TransactionsFact] WITH CHECK CHECK CONSTRAINT [FK_TransactionsFact_Product];

ALTER TABLE [prod].[TransactionsFact] WITH CHECK CHECK CONSTRAINT [FK_TransactionsFact_User];

ALTER TABLE [prod].[UsersDim] WITH CHECK CHECK CONSTRAINT [FK_UsersDim_SubTerritories];

ALTER TABLE [prod].[SubTerritoriesDim] WITH CHECK CHECK CONSTRAINT [FK_SubTerritories_Territories];

ALTER TABLE [stage].[Transactions] WITH CHECK CHECK CONSTRAINT [FK_StageTransactions_DateKey];

ALTER TABLE [stage].[Transactions] WITH CHECK CHECK CONSTRAINT [FK_StageTransactions_ExchangeRateId];

ALTER TABLE [stage].[Transactions] WITH CHECK CHECK CONSTRAINT [FK_StageTransactions_ProductId];

ALTER TABLE [stage].[Transactions] WITH CHECK CHECK CONSTRAINT [FK_StageTransactions_UserId];

ALTER TABLE [stage].[SubTerritories] WITH CHECK CHECK CONSTRAINT [FK_SubTerritories_Territories];

ALTER TABLE [stage].[Users] WITH CHECK CHECK CONSTRAINT [FK_StageUsers_SubTerritories];


GO
PRINT N'Update complete.';


GO
